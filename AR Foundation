※ 2강. AR Scene의 필수 Component를 사용 / AR Raycast를 통해 Object 생성

◎ 활용예제 : 지면(표면)을 감지하고 감지된 지면(표면)에 원하는 Object를 터치로 배치
◎ 방법
  ● 터치한 지점을 기준으로(즉, 화면공간에서 터치한 지점을 기준으로)
  ● 그 기준을 AR 공간상으로 옮겨서
  ● AR 공간상에서 Ray라는 광선을 쏘아서(Raycast)
  ● 그 광선에 닿는 지면(표면)의 위치를 감지한다.(감지한 곳에 원하는 Object를 생성..)
  
◎ 실습

** AR Session에 AR Input Manager가 있어서 사용자의 입력을 감지할 수 있다.(즉, 터치 감지 가능)
** 그래서 (감지된) 터치를 Script파일에서 사용할 수 있다.
** 다만, Raycast를 사용하기 위해서는(감지된 터치를 통해서 눈에 보이지 않는 광선을 쏘는 부분)
** Scene에새로운 Component가 최소 하나가 필요하고, 그것을 AR Session Origin에 추가해야 한다.
   (AR Session Origin Component가 추가되어 있는 Object에 AR Raycast Manager Component를 추가한다.)
   ▶ AR Session Origin에 추가해야 하는 이유 : AR Session Origin이 AR 공간의 기준이 된다.



(1) Cube Object를 Prefab으로 만들기(만들고 Hierarchy창에 있는 Cube Object는 삭제)
(2) Script 파일 생성

[ OOOOOO.cs 파일 ]
...
...
using UnityEngine.XR.ARFoundation; // AR Foundation을 사용하기 위해 추가
using UnityEngine.XR.ARSubsystems; // AR Raycast를 사용하기 위해 추가

▶ ARFoundation : AR 관련 중요한 Component들이 선언되어 있다.
▶ ARSubsystems : AR 관련 Subsystem, 부가적인 편의 기능들이 선언되어 있다.
 
...
...
 
  public ARRaycastManager arRAycaster; // ARRAycastManager가 Raycast를 실행한다. (Raycast를 사용하기 위해)
  
  public GameObject spawnPrefab; // 터지할 지점에 생성할 GameObject Prefab(생성할 Target)

  // void Start() 함수는 삭제(이번 예제에서는 필요 없음) //
  
  void Update()
  {
    (1) 일단 매 프레임마다 입력을 감지해야 한다.(터치 감지)
    
    // 입력을(터치를) 한번도 하지 않았다면 Update Method 바로 종료.
    if(Input.touchCount == 0) { return; }
    
    ▶ Input.touchCount : AR 관련 Library가 아니고, Unity에 원래 속해있는.., 현재 프레임에서 화면에 몇 번 입력이(터치가) 되었는지 알 수 있다.
    
    (2) 만약, 여러 번을 입력했다면(터치했다면), 그 중에서 첫 번째 입력 지점(터치 지점)을 사용할 것이다.
    
    // 여러 개의 입력지점(터치지점) 중에서 GetTouch에 지정한 Index에 해당하는 입력 값(터치 값)에 대한 정보만 알려준다.(가장 처음의 입력(터치)정보만)   
    // Touch 타입으로 정보를 알려주므로 Touch 자료형(?)인 touch에 정보를 저장한다.
    Touch touch = Input.GetTouch(0);
    
    ▷ Q. GetTouch말고 Input.GetMouseButton은 사용할 수 없을까? 
       A. 사용할 수 없다. Mouse와 관련된 Library는 사용하면 안 된다.
       
       이유) Input.GetTouch Method를 사용하게 되면 Vector나 boolean 같은 그 Type 그대로 정보를 받아오는 것이 아니라
             여러 개의 입력 정보(터치 정보)가 하나의 Contain으로 포함되어 Touch Type으로 정보를 불러온다.(가져온다/받는다)
             즉, GetMouseButton과 차이점은 Touch Type은 '위치, 클릭 정보'에 더하여 '지금 입력(터치)를 하는 시점인지, 입력을(터치를) 떼는 시점인지' 등의 부가정보도 함께 있다.
             
             그러나 GetMouseButton은 그렇지 않다.
             예를 들어, Input.GetMouseButtonDown(0)을 사용하게 되면 bool값만(true 또는 false) 받을 수 있다.
             단어 그대로 지금(현재) 마우스버튼을 클릭했는지 안했는지의 정보만 알 수 있고, 여러 부가 정보도 알 수 없다
             그래서 GetMouseButton Method를 사용하면 다른 별게의 Method를 또 사용해야 하므로 코드가 길어질(복잡) 수 있다.
             

그래서 별게의 다른 함수를 또 사용해야하므로(즉, 마우스 관련 함수로 현재 예제코드를 작성하려면 코드가 복잡해짐)

지금 예제에서는 touch 타입 하나로 사용하는 것이 가장 좋다.(왜? 모바일 기기를 대상으로 하니까)
    
  
  
  }


